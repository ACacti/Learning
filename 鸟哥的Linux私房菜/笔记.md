第二章 主机规划与磁盘分区

## 2.2磁盘分区

> 盘面中一圈圈同心圆为一条条磁道（磁轨），从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁上一个弧段被称之为一个扇区（磁区）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节)
>
> <img src="笔记.assets/1.png" alt="磁头与柱面" style="zoom: 67%;" />
>
> 硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。

### 2.2.1 磁盘连接的方式与配置文件名的关系

正常的实体机器大概使用的都是**/dev/sd[a-]**的磁盘名，至于虚拟机环境下，为了加速，可能就会使用**/dev/vd[a-p]**这种装置文件名。

| 装置              | 装置在Linux内的文件名                                        |
| ----------------- | ------------------------------------------------------------ |
| SCSI/SATA/USB硬驱 | /dev/sd[a-p]                                                 |
| USB快闪碟         | /dev/sd[a-p] （与SATA相同）                                  |
| VirtI/O界面       | /dev/vd[a-p] （用于虚拟机内）                                |
| 软碟机            | /dev/fd[0-1]                                                 |
| 打印机            | /dev/lp[0-2] （25针打印机） /dev/usb/lp[0-15] （USB 接口）   |
| 鼠标              | /dev/input/mouse[0-15] （通用） /dev/psaux （PS/2界面） /dev/mouse （当前鼠标） |
| CDROM/DVDROM      | /dev/scd[0-1] （通用） /dev/sr[0-1] （通用，CentOS 较常见） /dev/cdrom （当前 CDROM） |
| 磁带机            | /dev/ht0 （IDE 界面） /dev/st0 （SATA/SCSI界面） /dev/tape （当前磁带） |
| IDE硬盘机         | /dev/hd[a-d] （旧式系统才有）                                |

### 2.2.2 MSDOS(MBR)与GPT磁盘分割表（partition table）

#### 1. MSDOS(MBR) 分割表格式与限制

早期的 Linux 系统为了兼容于 Windows 的磁盘，因此使用的是支持 Windows 的 MBR（Master Boot Record， 主要开机纪录区） 的方式来处理开机管理器与分割表！ 而启动管理程序纪录区与分割表则通通放在磁盘的第一个扇区， 这个扇区通常是 512bytes 的大小 （旧的磁盘扇区都是 512bytes 喔！ ），所以说，第一个磁区 512bytes 会有这两个数据：

- 主要开机记录区（Master Boot Record， MBR）：可以安装开机管理程序的地方，有446 bytes
- 分割表（partition table）：记录整颗硬盘分割的状态，有64 bytes

由于分割表所在区块仅有64 bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。 若将硬盘以长条形来看，然后将磁柱以直条图来看，那么那64 bytes的记录区段有点像底下的图标：

<img src="笔记.assets/2.png" />

上述四个分割槽在Linux系统中设备文件名为：

- P1:/dev/sda1
- P2:/dev/sda2
- P3:/dev/sda3
- P4:/dev/sda4

由于分割表就只有64 bytes而已，最多只能容纳四笔分割的记录， 这四个分割的记录被称为主要（Primary）或延伸（Extended）分割槽。 根据上面的图标与说明，我们可以得到几个重点信息：

- 其实所谓的'分割'只是针对那个64 bytes的分割表进行设定而已！
- 硬盘预设的分割表仅能写入四组分割信息
- 这四组分割信息我们称为主要（Primary）或延伸（Extended）分割槽
- 分割槽的最小单位'通常'为磁柱（cylinder）
- 当系统要写入磁盘时，一定会参考磁盘分割表，才能针对某个分割槽进行数据的处理

使用分割表的意义：

* 数据安全性

  当需要将某个分区的数据重整时（例如装系统），其它分区的数据不受影响。

* 系统效能考量

  在系统读取某个分区的数据时，磁盘只要搜索本分区范围内的磁柱即可。

尽管第一个磁区所在的扇区（磁区）只能记录四笔数据，但可以利用额外的磁区来记录更多的分割信息（**拓展分割**）：

<img src="笔记.assets/3.png" />

* 上图中P1为**主要分割**， P2为**延伸分割**（硬盘限制两种分割数之和最多四笔，操作系统限制延伸分割最多一个）。 
* 延伸分割的目的是使用额外的扇区来记录分割信息，延伸分割本身不能被拿来格式化。
* 上图中五个由延伸分割继续切出来的分割槽，被称为**逻辑分割槽** 。
* 由于逻辑分割槽是有延伸分割继续分割出来的，所以其可以使用柱面范围就是延伸分割所设定的范围。

上图中由于前四个号码是保留给主要分割或延伸分割使用，所以逻辑分割槽的号码是由5号开始：

- P1:/dev/sda1
- P2:/dev/sda2
- L1:/dev/sda5
- L2:/dev/sda6
- L3:/dev/sda7
- L4:/dev/sda8
- L5:/dev/sda9

MBR分割表的限制：

- 操作系统无法获取到 2.2T 以上的磁盘容量！
- MBR 仅有一个区块，若被破坏后，经常无法或很难救援。
- MBR 内的存放开机管理程序的区块仅 446bytes，无法容纳较多的代码。

#### 2. GUID paritiontable, GPT磁盘分割表

GPT为兼容所有硬盘，在磁区的定义上面，使用逻辑区块地址LBA（块/簇）,默认为512Bytes。

与 MBR 仅使用第一个 512bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分割信息。 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份。

<img src="笔记.assets/4.jpg" />

上述图标的解释说明如下：

- LBA0 （MBR 兼容区块）

  与 MBR 模式相似的，这个兼容区块也分为两个部份，一个就是跟之前 446 bytes 相似的区块，储存了第一阶段的开机管理程序！ 而在原本的分割表的纪录区内，这个兼容模式仅放入一个特殊标志的分割，用来表示此磁盘为 GPT 格式之意。 而不懂 GPT 分割表的磁盘管理程序， 就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分割信息，进一步保护了此磁盘喔！

- LBA1 （GPT 表头纪录）

  这个部分纪录了分割表本身的位置与大小，同时纪录了备份用的 GPT 分割 （就是前面谈到的在最后 34 个 LBA 区块） 放置的位置， 同时放置了分割表的检验机制码 （CRC32），操作系统可以根据这个检验码来判断 GPT 是否正确。 若有错误，还可以通过这个记录区来取得备份的 GPT（磁盘最后的那个备份区块） 来恢复 GPT 的正常运作！

- LBA2-33 （实际日志分信息处）

  从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分割纪录，所以在预设的情况下，总共可以有 4*32 = 128 笔分割纪录喔！ 因为每个LBA有512bytes，因此每笔纪录用到128 bytes的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT在每笔纪录中分别提供了64bits来记载开始/结束的磁区号码，因此，GPT分割表对于单一分割槽来说，他的最大容量限制就会在' 2^64 * 512bytes = 2^63 * 1Kbytes = 2^33*TB = 8 ZB ，要注意 1ZB = 2^30 TB 啦！

  

  查资料补充：

> 块/簇： 磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。
>
> 为什么存在磁盘块：
>
> * 读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。
> * 分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。
>
> page: 操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。
>
> 扇区、块/簇、page的关系：
>
> * 扇区： 硬盘的最小读写单元
> * 块/簇： 是操作系统针对硬盘读写的最小单元
> * page： 是内存与操作系统之间操作的最小单元。
> * 扇区 <= 块/簇 <= page

### 2.2.3 开机流程中的BIOS与UEFI开机检测程序

#### 1. BIOS搭配MBR/GPT的开机流程：

1. **BIOS**：开机主动执行的韧体，会认识第一个可开机的装置;
2. **MBR**：第一个可开机装置的第一个磁区内的主要开机记录区块，内含开机管理程序;
3. **启动管理器（boot loader）**：一支可读取核心文件来执行的软件;
4. **核心文件**：启动操作系统的功能...

开机管理器除了可以安装在MBR之外， 还可以安装在每个分割槽的开机扇区（boot sector）。

例如：

<img src="笔记.assets/5.gif" />

- 每个分割槽都拥有自己的开机扇区（boot sector）
- 图中的系统槽为第一及第二分割槽，
- 实际可开机的核心文件是放置到各分割槽内的！
- loader只会认识自己的系统槽内的可开机核心文件，以及其他loader而已;
- loader可直接指向或者是间接将管理权转交给另一个管理程序。

#### 2. UEFI BIOS搭配GPT开机的流程

UEFI主要是想要取代BIOS这个固件界面， 使用 C 程序语言，比起使用组合语言的传统 BIOS 要更容易开发。

EFI 大多用来作为启动操作系统之前的硬件检测、开机管理、软件设定等目的，基本上是比较难的。 同时，当加载操作系统后，一般来说，UEFI 就会停止工作，并将系统交给操作系统，这与早期的 BIOS 差异不大。 

### 2.2.4 Linux安装模式下，磁盘分割的选择

#### 1. 目录树结构

![图2.2.9、目录树相关性示意图](%E7%AC%94%E8%AE%B0.assets/dirtree.gif)

#### 2. 文件系统和目录树的关系（挂载）

所谓的'挂载'就是利用一个目录当成进入点，将磁盘分割槽的数据放置在该目录下; 也就是说，进入该目录就可以读取该分割槽的意思。

![图2.2.10、目录树与分割槽之间的相关性](%E7%AC%94%E8%AE%B0.assets/dir_3.png)

# 第四章、首次登入与线上求助

## 4.1首次登陆系统

### 4.1.4 在终端接口登入Linux

 Linux默认的情况下会提供六个Terminal来让用户登录， 切换的方式为使用：**[Ctrl] + [Alt] + [F1]~[F6]**的组合按钮。

- [Ctrl] + [Alt] + [F2] ~ [F6] ：文本接口登录 tty2 ~ tty6 终端机;
- [Ctrl] + [Alt] + [F1] ：图形界面桌面。

## 4.2文字模式下指令的下达

### 4.2.1 开始下达指令

指令格式

```shell
[dmtsai@study ~]$ command  [-options]  parameter1  parameter2 ...
                     指令     選項        參數(1)     參數(2)
```

上述指令详细说明如下：

1. 一行指令中第一个输入的部分绝对是'指令（command）'或'可执行文件（例如批次脚本，script）'
2. command 为指令的名称，例如变换工作目录的指令为 cd 等等;
3. 中刮号[]并不存在于实际的指令中，而加入选项设定时，通常选项前会带 - 号，例如 -h;有时候会使用选项的完整全名，则选项前带有 -- 符号，例如 --help;
4. parameter1 parameter2.. 为依附在选项后面的参数，或者是 command 的参数;
5. 指令， 选项， 参数等这几个咚咚中间以空格来区分，不论空几格 shell 都视为一格。 所以空格是很重要的特殊字符！ ；
6. 按下[Enter]按键后，该指令就立即执行。 [Enter]按键代表着一行指令的开始启动。
7. 指令太长的时候，可以使用反斜线 （\） 来跳脱 [Enter] 符号，使指令连续到下一行。 注意！ 反斜线后就立刻接特殊字符，才能跳脱！

#### 1. 语系的支持

```shell
1. 顯示目前所支援的語系
[dmtsai@study ~]$ locale
LANG=zh_TW.utf8              # 語言語系的輸出
LC_CTYPE="zh_TW.utf8"        # 底下為許多資訊的輸出使用的特別語系
LC_NUMERIC=zh_TW.UTF-8
LC_TIME=zh_TW.UTF-8          # 時間方面的語系資料
LC_COLLATE="zh_TW.utf8"
....中間省略....
LC_ALL=                      # 全部的資料同步更新的設定值
# 上面的意思是說，目前的語系(LANG)為zh_TW.UTF-8，亦即台灣繁體中文的萬國碼
[dmtsai@study ~]$ date
鈭? 5??29 14:24:36 CST 2015  # 純文字界面下，無法顯示中文字，所以前面是亂碼

2. 修改語系成為英文語系
[dmtsai@study ~]$ LANG=en_US.utf8
[dmtsai@study ~]$ export LC_ALL=en_US.utf8
# LANG 只與輸出訊息有關，若需要更改其他不同的資訊，要同步更新 LC_ALL 才行！

[dmtsai@study ~]$ date
Fri May 29 14:26:45 CST 2015 # 順利顯示出正確的英文日期時間啊！

[dmtsai@study ~]$ locale
LANG=en_US.utf8
LC_CTYPE="en_US.utf8"
LC_NUMERIC="en_US.utf8"
....中間省略....
LC_ALL=en_US.utf8
# 再次確認一下，結果出現，確實是en_US.utf8這個英文語系！
```

### 4.2.2 基本指令操作

- 显示日期与时间的指令： date

- 显示日历的指令： cal 

  `cal [month] [year]`

- 简单好用的计算机： bc

  `scale=3`: 显示小数点后三位

- 命令补全 `[tab]`按键

  - [Tab] 接在一串指令的第一个字的后面，则为『命令补全』;
  - [Tab] 接在一串指令的第二个字以后时，则为『档案补齐』！
  - 若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！

- `[ctr]+c`:终止正在运行的指令

- `[ctr] + d`: 键盘输入结束

- `[shift]+{[PageUp] | [PageDown]}`:文本模式时上下翻页

- 查看某指令的说明

  * `command --help`
  * `man command`

### 4.3.2 man page

man page页面命令后数字代表含义：

| 代号 | 代表内容                                                     |
| ---- | ------------------------------------------------------------ |
| 1    | **用户在shell环境中可以操作的指令或可执行文件**              |
| 2    | 系统核心可调用的函数与工具等                                 |
| 3    | 一些常用的函数（function）与函式库（library），大部分为C的函式库（libc） |
| 4    | 装置文件的说明，通常在/dev下的文件                           |
| 5    | **配置文件或者是某些文件的格式**                             |
| 6    | 游戏（games）                                                |
| 7    | 惯例与协议等，例如Linux文件系统、网路协定、ASCII code等等的说明 |
| 8    | **系统管理员可用的管理指令**                                 |
| 9    | 跟kernel有关的文件                                           |

文字模式下常用按键

| 按键        | 进行工作                                                     |
| ----------- | ------------------------------------------------------------ |
| 空白键      | 向下翻一页                                                   |
| [Page Down] | 向下翻一页                                                   |
| [Page Up]   | 向上翻一页                                                   |
| [Home]      | 去到第一页                                                   |
| [End]       | 去到最后一页                                                 |
| /string     | 向'下'搜寻 string 这个字符串，如果要搜索 vbird 的话，就输入 /vbird |
| ?string     | 向'上'搜寻 string 这个字符串                                 |
| n, N        | 利用 / 或 ？ 来搜索字符串时，可以用 n 来继续下一个搜索 （不论是 / 或 ？） ，可以利用 N 来进行「反向」搜索。 举例来说，我以 /vbird 搜寻 vbird 字符串， 那么可以 n 继续往下查询，用 N 往上查询。 若以 ？vbird 向上查询 vbird 字符串， 那我可以用 n 继续「向上」查询，用 N 反向查询。 |
| q           | 结束这次的 man page                                          |

#### 1. 搜索特定命令/文件的man page 说明文件

使用`man -f command`命令搜索相应命令的man page文件。

```shell
#搜索man命令的man page 说明文件
[dmtsai@study ~]$ man -f man
man (1)              - an interface to the on-line reference manuals
man (1p)             - display system documentation
man (7)              - macros to format man pages

#查看man(1)的文件资料
[dmtsai@study ~]$ man 1 man
```

使用`man -k command`命令，列出所有包含`command`字眼的说明文件。

```shell
[dmtsai@study ~]$ man -k man
fallocate (2)        - manipulate file space
zshall (1)           - the Z shell meta-man page
...
```

在以root身份建立`whatis`数据库

```shell
[root@study ~]# mandb
```

之后就可以使用两个`man`命令的缩写版

```shell
[dmtsai@study ~]$ whatis  [指令或者是資料]   <==相當於 man -f [指令或者是資料]
[dmtsai@study ~]$ apropos [指令或者是資料]   <==相當於 man -k [指令或者是資料]
```

### 4.3.3 info  page

在Linux里面则又额外提供了一种线上求助的方法--info。

`info page`显示解读：

```shell
[dmtsai@study ~]$ info info
File: info.info,  Node: Top,  Next: Getting Started,  Up: (dir)

Info: An Introduction
*********************

The GNU Project distributes most of its on-line manuals in the "Info
format", which you read using an "Info reader".  You are probably using
an Info reader to read this now.
....(中間省略)....

   If you are new to the Info reader and want to learn how to use it,
type the command 'h' now.  It brings you to a programmed instruction
sequence. # 這一段在說明，按下 h 可以有簡易的指令說明！很好用！
....(中間省略)....

* Menu:

* Getting Started::             Getting started using an Info reader.
* Advanced::                    Advanced Info commands.
* Expert Info::                 Info commands for experts.
* Index::                       An index of topics, commands, and variables.

--zz-Info: (info.info.gz)Top, 52 lines --Bot------------------------------------------
```

- File：代表这个info page的数据是来自 info.info 文件所提供的;
- Node：代表目前的这个页面是属于Top节点。 意思是 info.info 内含有很多信息，而Top仅是 info.info 文件内的一个节点内容而已;
- Next：下一个节点的名称为Getting Started，你也可以按'N'到下个节点去;
- Up：回到上一层的节点总揽画面，你也可以按下'U'回到上一层;
- Prev：前一个节点。 但由于Top是 info.info 的第一个节点，所以上面没有前一个节点的信息。

另外，如论你在任何一个页面，只要不知道怎么使用 info 了，直接按下 h 系统就能够提供一些基本按键功能的介绍。

阅读`info page`界面常用按键

| 按键        | 进行工作                                            |
| ----------- | --------------------------------------------------- |
| 空白键      | 向下翻一页                                          |
| [Page Down] | 向下翻一页                                          |
| [Page Up]   | 向上翻一页                                          |
| [tab]       | 在 node 之间移动，有 node 的地方，通常会以 * 显示。 |
| [Enter]     | 当光标在 node 上面时，按下 Enter 可以进入该 node 。 |
| b           | 移动光标到该info画面当中的第一个node处              |
| e           | 移动光标到该info画面当中的最后一个node处            |
| n           | 前往下一个 node 处                                  |
| p           | 前往上一个 node 处                                  |
| u           | 向上移动一层                                        |
| s(/)        | 在 info page 当中进行搜寻                           |
| h, ?        | 显示求助菜单                                        |
| q           | 结束这次的 info page                                |

### 4.3.4 其它有用的文件

文件目录：/usr/share/doc

# 五、Linux文件权限与目录配置

## 5.2 Linux文件权限概念

### 5.2.1 Linux文件属性

使用`ls -al`命令查看当前目录所有文件以及文件属性。

```shell
[root@study ~]# ls -al
total 48
drwxr-xr-x.  3    root     root      17  May  6 00:14 .config               <=範例說明處
drwx------.  3    root     root      24  May  4 17:59 .dbus
-rw-r--r--.  1    root     root    1864  May  4 18:01 initial-setup-ks.cfg  <=範例說明處
....
```

文件属性示意：

![文件属性的示意图](%E7%AC%94%E8%AE%B0.assets/centos7_0210filepermission_2.gif)

> 连结应该类似windows系统的快捷方式（猜想未证实）。

文件属性详细介绍：

1. 第一列代表这个文件的类型与权限

   ![image-20220325212126144](%E7%AC%94%E8%AE%B0.assets/image-20220325212126144.png)

   * 第一个字母代表这个文件是目录、文件、或链接文件等等
     - 当为[ **d** ]则是目录
     - 当为[ **-** ]则是文件
     - 若是[ **l** ]则表示为链接文件（link file）;
     - 若是[ **b** ]则表示为设备文件里面的可供储存的周边设备（可随机存取装置）;
     - 若是[ **c**]则表示为设备文件里面的串口设备，例如键盘、鼠标（一次性读取设备）。
   * 接下来的字符中，三个为一组
     - 第一组为'文件所有者可具备的权限'
     - 第二组为'加入此群组之帐号的权限';
     - 第三组为'非本人且没有加入本群组之其他帐号的权限'。

2. 第二栏表示有多少文件名链接到此节点（i-node）

   每个文件都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用文件名来记录， 因此每个文件名就会连结到一个i-node。这个属性记录的，就是有多少不同的文件名链接到相同的一个i-node号码。(第七章详解)
   
3. 第三列表示此文件（或目录）的'所有者帐号'

4. 第四列表示这个文件的所属组

   Linux系统下，一个账号可以加入多个组。

5. 第五栏为这个文件的容量大小，单位为Bytes.

6. 第六列为此文件的建档日期或者是最近的修改日期

7. 第七栏为这个文件的文件名

### 5.2.2 如何改变文件属性与权限

- `chgrp [-R] groupName dirname/filename ...` ：改变文件所属组

  * 要改变的群组名必须在`etc/group`文件内存在才可以。

  * `-R`参数: 进行递归的持续变更，即连同子目录下的所有文件、目录都更新为这个新的群组

  * 示例：

    ```shell
    [root@study ~]# chgrp users initial-setup-ks.cfg
    [root@study ~]# ls -l
    -rw-r--r--. 1 root users 1864 May  4 18:01 initial-setup-ks.cfg
    ```

- `chown `：改变文件所有者

  * 用户必须在`etc/passwd`这个文件中有记录。
  * 用法：
    * `chown [-R] 账号名称 文件或目录`
    * `chown -[R] 账号名称：组名 文件或目录`

- `chmod` ：改变文件的权限， SUID， SGID， SBIT等等的特性

  * 数字类型改变文件权限

    文件权限字符为：`[-rwxrwxrwx]`, r 、w、 x权限的分数分别为4、2、1

    例如一个文件的权限字符为`[-rwxrwx---]`,各身份分数则是：

    owner = rwx = 4 + 2 + 1 = 7

    group = rwx = 4 + 2 + 1 = 7

    others = --- = 0 + 0 + 0 =0

    * `chmod [-R] xyz 文件或目录`

      `xyz`: 就是该文件数字类型的权限分数之和。

      `-R`: 进行递归的持续变更。

      示例：

      ```shell
      [root@study ~]# ls -al .bashrc
      -rw-r--r--. 1 root root 176 Dec 29  2013 .bashrc
      [root@study ~]# chmod 777 .bashrc
      [root@study ~]# ls -al .bashrc
      -rwxrwxrwx. 1 root root 176 Dec 29  2013 .bashrc
      ```

  * 符号类型改变文件权限

    ![image-20220327005432589](%E7%AC%94%E8%AE%B0.assets/image-20220327005432589.png)

    * 在`chmod`命令中，可以分别使用 u、g、o分别代表user、group、others三种身份，另外使用a代表上述全部身份。

      一种使用符号类型改变文件权限的命令：`chmod u=rwx，g=rx，o=r filename`

      示例：

      ```shell
      [root@study ~]# chmod  u=rwx,go=rx  .bashrc
      [root@study ~]# ls -al .bashrc
      -rwxr-xr-x. 1 root root 176 Dec 29  2013 .bashrc
      ```

    * 使用 `+` 、`-`符号分别来加入或去除`u`、`g`、`o`等身份的`rwx`权限

      示例：

      ```shell
      [root@study ~]# ls -al .bashrc
      -rwxr-xr-x. 1 root root 176 Dec 29  2013 .bashrc
      [root@study ~]# chmod  a+w  .bashrc #给全部身份都提供写入权限
      [root@study ~]# ls -al .bashrc
      -rwxrwxrwx. 1 root root 176 Dec 29  2013 .bashrc
      ```

### 5.2.3 目录和文件的权限意义

1. 权限对**目录**的重要性

   * r (read contents in directory):

     表示具有读取目录内结构清单的权限。

     （`ls` 命令无法查看该目录下文件）

   * w(modify contents of directory)：

     表示你具有异动该目录结构清单的权限。

     - 建立新的文件与目录;
     - 删除已经存在的文件与目录（不论该文件的权限为何！ )
     - 将已存在的文件或目录进行更名;
     - 搬移该目录内的文件、目录位置。

   * x (access directory)：

     目录的x代表的是用户能否进入该目录成为工作目录的用途。

     （`cd` 命令无法进入该文件夹）

2. 权限对文件的重要性

   - r （read）：可读取此一文件的实际内容，如读取文字文件的文字内容等;
   - w （write）：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）;
   - x （execute）：该文件具有可以被系统执行的权限。

3. 示例

   现有目录结构如下：

   * `/dir1/file1`
   * `/dir2`

   给文件/目录分配最小权限来达成任务:

   | 操作动作              | /dir1 | /dir1/file1 | /dir2 | 重点                                      |
   | --------------------- | ----- | ----------- | ----- | ----------------------------------------- |
   | 读取 file1 内容       | x     | r           | -     | 要能够进入 /dir1 才能读到里面的文件资料！ |
   | 修改 file1 内容       | x     | rw          | -     | 能够进入 /dir1 且修改 file1 才行！        |
   | 执行 file1 内容       | x     | rx          | -     | 能够进入 /dir1 且 file1 能运作才行！      |
   | 删除 file1 文件       | wx    | -           | -     | 能够进入 /dir1 具有目录修改的权限即可！   |
   | 将 file1 复制到 /dir2 | x     | r           | wx    | 要能够读 file1 且能够修改 /dir2 内的数据  |

   > 开放一个目录，通常需要具备`rx`这两个权限。

### 5.2.4 Linux文件种类与拓展名

1. 文件种类

   * 正规文件（regular file）

     使用`ls -l`命令列出的文件属性为 `[-]`

     * 纯文本文档（ASCII）

     * 二进制文件（binary）

       Linux中的可执行文件就是这种格式。

     * 数据格式文件（data）

       有些程序在运作的过程中会读取到某些特定格式的文件，那些特定格式的文件可以被称为数据文件。

   * 目录（directory）

     文件属性为`[d]`。

   * 链接档（link）

     类似Windows系统中快捷方式，文件属性为`[l]`。

   * 设备与装置文件（device）

     * 区块设备档：就是一些储存数据，以提供系统随机存取的接口设备，例如硬盘和软盘。文件属性为`[b]`。
     * 字符设备文件：即一些串行端口的接口设备，例如键盘、鼠标等。文件属性为`[c]`。

   * 资料接口文件（sockets）

     我们可以启动一个程序来监听客户端的要求， 而客户端就可以通过这个socket来进行数据的沟通了。 文件属性为 `[s]`。 常在`/run`或`/tmp`目录中看到。

   * 资料输送文件（FIFO, pipe）

     FIFO也是一种特殊的档案类型，他主要的目的在解决多个程序同时访问一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。 第一个属性为`[p] `。

2. Linux文件拓展名：

   **一个Linux档案能不能被执行，与它的十个文件属性有关， 与文件名根本一点关系也没有**。但通常我们还是会以适当的副档名来表示该档案是什么种类的。

   常用拓展名：

   - `*.sh `： 脚本或批次文件 （scripts），因为批次文件为使用shell写成的;
   - `*Z`，` *.tar`， `*.tar.gz`， `*.zip`，` *.tgz`： 经过打包的压缩文件。 这是因为压缩软件分别为 gunzip， tar 等等的，由于不同的压缩软件，而取其相关的扩展名！
   - `*.html`， `*.php`：网页相关档案，分别代表 HTML 语法与 PHP 语法的网页文件。

3. Linux文件名长度限制

   - 单一档案或目录的最大容许文件名为 255bytes，以一个 ASCII 英文占用一个 bytes 来说，则大约可达 255 个字符长度。 若是以每个中文字占用 2bytes 来说， 最大档名就是大约在 128 个中文字之间。

4. Linux文件名限制

   由于Linux在文字界面下的一些指令操作关系，一般来说，你在设定Linux底下的档案名称时， 最好可以避免一些特殊字符比较好！ 例如底下这些：

   > \* ? > < ; & ! [ ] | \ ' " ` ( ) { }

## 5.3 Linux目录配置

### 5.3.1 Linux 目录配合的依据 FHS

（乍看一头雾水，看完后面内容回头再看可能好些）

FHS根据文件系统所使用的频繁与否与是否允许用户随意更动， 而将目录定义成为四种交互作用的形态：

- 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与使用者的邮件等资料， 是能够分享给网络上其他主机挂载用的目录;
- 不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。
- 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文档说明文件、系统管理员所管理的主机服务配置文件等等;
- 可变动的：经常改变的资料，例如登录文件、一般用户可自行收受的新闻群组等。

下为一些代表性目录：

![image-20220328161543984](%E7%AC%94%E8%AE%B0.assets/image-20220328161543984.png)

FHS针对目录树架构仅定义出三层目录底下应该放置什么文件：

- `/` （root， 根目录）：与开机系统有关;
- `/usr` （unix software resource）：与软件安装/执行有关;
- `/var `（variable）：与系统运作过程有关。



1. **根目录`（/） `的意义和内容**

   FHS标准建议：根目录（/）所在分区槽应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分割槽内，保持根目录越小越好。 如此不但效能较佳，根目录所在的档案系统也较不容易发生问题。

   <img src="%E7%AC%94%E8%AE%B0.assets/image-20220328163347851.png" alt="image-20220328163347851"  />

   ![image-20220328163527317](%E7%AC%94%E8%AE%B0.assets/image-20220328163527317.png)

2. `/usr `的意义与内容：

   > usr是Unix Software Resource的缩写。

   因为是所有系统预设的软件（distribution发布者提供的软件）都会放置到/usr底下，因此这个目录有点类似Windows 系统的'C：\Windows\ （当中的一部份） + C：\Program files\'这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。

   ![image-20220328163832222](%E7%AC%94%E8%AE%B0.assets/image-20220328163832222.png)

   ![image-20220328163907586](%E7%AC%94%E8%AE%B0.assets/image-20220328163907586.png)

3. `/var` 的意义与内容：

   `/var`目录主要针对常态性变动的文件，包括缓存（cache）、登录文件（log file）以及某些软件运作所产生的档案， 包括程序文件（lock file， run file），或者例如MySQL数据库的档案等等。

   

   ![image-20220328164314208](%E7%AC%94%E8%AE%B0.assets/image-20220328164314208.png)

4. 针对FHS，各家distributions的异同，与CentOS7的变化

   - /bin --> /usr/bin
   - /sbin --> /usr/sbin
   - /lib --> /usr/lib
   - /lib64 --> /usr/lib64
   - /var/lock --> /run/lock
   - /var/run --> /run

### 5.3.2 目录树

![目录树架构示意图](%E7%AC%94%E8%AE%B0.assets/centos7_0210filepermission_4.jpg)

# 六、Linux文件与目录管理

 ## 6.1 目录与路径

### 6.1.2 目录的相关操作

* `.`：代表当前目录

* `..`：代表上一层目录

* `-`：代表上一个工作目录

* `~`：代表当前使用者的`home`目录

`~account`：  代表account账号的`home`目录

常用处理目录的指令：

* `cd`：更换目录

* `pwd -[p]`：显示当前目录

  `-p`：显示确实的路径，而非使用链接路径。

* `mkdir -[mp]`：建立一个新目录

  `-m`：设定文件权限，默认使用系统预设权限。

  `-p`：直接将需要的目录（包含上层目录）递归建立起来。

  示例：

  ```shell
  [root@study tmp]# mkdir -p test1/test2/test3/test4
  
  建立权限为rwx--x--x的目錄
  [root@study tmp]# mkdir -m 711 test2 #同 mkdir -m u=rwx,g=x,o=x test2
  [root@study tmp]# ls -ld test*
  drwxr-xr-x. 3 root   root 18 Jun  4 19:04 test1
  drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
  ```

* `rmdir -[p]`：删除一个空目录

  `-p`：连同上层空目录一起删除。

  示例：

  ```shell
  [root@study tmp]# ls -ld test*   <==看看有多少目錄存在？
  drwxr-xr-x. 3 root   root 18 Jun  4 19:04 test1
  drwx--x--x. 2 root   root  6 Jun  4 19:05 test2
  
  #删除mkdir示例新建的 test1/test2/test3/test4目录
  [root@study tmp]# rmdir -p test1/test2/test3/test4
  ```

  > 此命令仅删除空目录，如果想要删除含有文件的目录
  >
  > `rm -r diratoryPath`

### 6.1.3 关于可执行文件路径的变量：$PATH

当我们在执行一个指令的时候，例如`ls`命令，系统会依照PATH的设定去每个PATH定义的目录下搜索文件名为`ls`的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可执行文件，那么先搜寻到的同名指令先被执行。

PATH这个变量的内容是由一堆目录所组成的，每个目录中间用冒号（:)来隔开， 每个目录是有'顺序'之分的。

使用`echo $PATH`查看PATH定义的目录：

```shell
[dmtsai@study ~]$ echo $PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
```

追加`$PATH`路径：

```shell
[root@study ~]# PATH="${PATH}:/root"
#效果同上
[root@study ~]# PATH=$PATH:/root
```

## 6.2 文件与目录管理

### 6.2.1 文件与目录的查看：ls

```shell
[root@study~]# ls [-aAdfFhilnrRSt]文件名或目录名称..
[root@study~]# ls [--color={never，auto，always}]文件名或目录名称..
[root@study~]# ls [--full-time]文件名或目录名称..
-a：全部的档案，连同隐藏档（开头为.的档案）一起列出来（常用）
-A：全部的档案，连同隐藏档，但不包括.与..这两个目录
-d：仅列出目录本身，而不是列出目录内的档案数据（常用）
-f：直接列出结果，而不进行排序（ls预设会以文件名排序！）
-F：根据档案、目录等信息，给予附加数据结构，例如：
*：代表可执行档；/：代表目录；=：代表socket档案；|：代表FIFO档案；
-h：将档案容量以人类较易读的方式（例如GB，KB等等）列出来；
-i：列出inode号码，inode的意义下一章将会介绍；
-l：长数据列表出，包含档案的属性与权限等等数据；（常用）
-n：列出UID与GID而非使用者与群组的名称（UID与GID会在帐号管理提到！）
-r：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；
-R：连同子目录内容一起列出来，等于该目录下的所有档案都会显示出来；
-S：以档案容量大小排序，而不是用文件名排序；
-t：依时间排序，而不是用文件名。
--color=never：不要依据档案特性给予颜色显示；
--color=always：显示颜色
--color=auto：让系统自行依据设定来判断是否给予颜色
--full-time：以完整时间模式（包含年、月、日、时、分）输出
--time={atime，ctime}：输出access时间或改变权限属性时间（ctime）,而非内容变更时间（modification time）
```

(可使用`ls --help`查看`ls`命令其它用法)

### 6.2.2 复制、删除与移动：cp，rm, mv

**`cp`复制文件或目录**

```shell
[root@study ~]# cp [-adfilprsu] 來源檔(source) 目標檔(destination)
[root@study ~]# cp [options] source1 source2 source3 .... directory
選項與參數：
-a：相当于-dr --preserve=all的意思，至于dr请参考下列说明；（常用）
-d：若来源档为连接档的属性（link file），则复制连接档属性而非档案本身；
-f：为强制（force）的意思，若目标档案已经存在且无法开启，则移除后再尝试一次；
-i：若目标档（destination）已经存在时，在覆盖时会先询问动作的进行（常用）
-l：进行硬式连接（hard link）的连接档建立，而非复制档案本身；
-p：连同档案的属性（权限、用户、时间）一起复制过去，而非使用预设属性（备份常用）；
-r：递归持续复制，用于目录的复制行为；（常用）
-s：复制成为符号连接档（symbolic link），亦即『捷径』档案；
-u :destination比source旧才更新destination，或destination不存在的情况下才复制。
--preserve=all：除了-p的权限相关参数外，还加入SELinux的属性，links，xattr等也复制了。
最后需要注意的，如果来源档有两个以上，则最后一个目的档一定要是『目录』才行！
```

* 在预设的条件中， cp 的来源文件与目的文件的权限是不同的，目的文件的所有者通常会是指令操作者本身。
* 普通用户一般没有修改文件所有者与群组的权限，因此即使使用`cp -a`命令也无法复制原文件的所有者和群组信息。

**`rm`删除文件或目录**

```shell
[root@study~]# rm [-fir]档案或目录
选项与参数：
-f：就是force的意思，忽略不存在的档案，不会出现警告信息；
-i：互动模式，在删除前会询问使用者是否动作(宜配合正则表达式使用)；
	在命令前加反斜杠可以忽略alias的指定选项（\rm -i）
-r：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！
```

**mv （移动文件和目录，或更名）**

```shell
[root@study~]# mv [-fiu] source destination
[root@study~]# mv [options] source1 source2 source3….directory
选项与参数：
-f :force强制的意思，如果目标档案已经存在，不会询问而直接覆盖；
-i：若目标档案（destination）已经存在时，就会询问是否覆盖！
-u：若目标档案已经存在，且source比较新，才会更新（update）

#如果有多个来源档案或目录，则最后一个目标档一定是『目录！』
#大量修改文件名，可以使用rename命令
```

### 6.2.3 取得路径的文件名称与目录名称

```shell
[root@study ~]# basename /etc/sysconfig/network
network         <== 取得文件名称
[root@study ~]# dirname /etc/sysconfig/network
/etc/sysconfig  <== 取得路径名称
```

## 6.3 文件内容查询

- `cat` 由第一行开始显示文件内容
- `tac` 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
- `nl `显示的时候，顺道输出行号！
- `more` 一页一页的显示文件内容
- `less` 与 `more` 类似，但是比 `more `更好的是，他可以往前翻页！
- `head` 只看头几行
- `tail` 只看尾巴几行
- `od` 以二进制的方式读取文件内容！

### 6.3.1 直接检视文件内容

`cat` `tac` `nl`.

* `cat`

  ```shell
  [root@study~]# cat [-AbEnTv]
  选项与参数：
  -A：相当于-vET的整合选项，可列出一些特殊字符而不是空白而已；
  -b：列出行号，仅针对非空白行做行号显示，空白行不标行号！
  -E：将结尾的断行字元$显示出来；
  -n：打印出行号，连同空白行也会有行号，与-b的选项不同；
  -T：将[tab]按键以^I显示出来；
  -v：列出一些看不出来的特殊字符
  ```

* `tac`(反向行示)

  `tac` 是由最后一行到第一行反向在屏幕上显示出来 。

* `nl`(添加行号打印)

  ```shell
  [root@study~]# nl [-bnw]档案
  选项与参数：
  -b：指定行号指定的方式，主要有两种：
  -b a：表示不论是否为空行，也同样列出行号（类似cat -n）；
  -b t：如果有空行，空的那一行不要列出行号（预设值）；
  -n：列出行号表示的方法，主要有三种：
  -n ln：行号在屏幕的最左方显示；
  -n rn：行号在自己字段的最右方显示，且不加0；
  -n rz：行号在自己字段的最右方显示，且加0；
  -w：行号字段的占用的字元数。
  ```

### 6.3.2 可翻页检视

* `more`（一页一页翻动）
  - `空白键` （space）：代表向下翻一页;
  - `Enter` ：代表向下翻'一行';
  - `/字符串 `：代表在这个显示的内容当中，向下搜索'字符串'这个关键词;
  - `:f `：立刻显示出文件名以及目前显示的行数;
  - `q `：代表立刻离开 more ，不再显示该档案内容。
  - `b `或 `[ctrl]-b` ：代表往回翻页，不过这动作只对档案有用，对管线无用。
* `less`（一页一页翻动）
  - `空格键` ：向下翻动一页;
  - `[pagedown]`：向下翻动一页;
  - `[pageup]` ：向上翻动一页;
  - `/字符串` ：向下搜索『字串』的功能;
  - `?字符串`：向上搜索『字串』的功能;
  - `n` ：重复前一个搜索 （与 / 或 ？ 有关！ )
  - `N `：反向的重复前一个搜索 （ 与 / 或 ？ 有关！ )
  - `g` ：前进到这个数据的第一行去;
  - `G `：前进到这个数据的最后一行去 （注意大小写）;
  - `q `：离开 `less `这个程序;

### 6.3.3 数据撷取

* `head`（取出前几行）

  ```shell
  [root@study~]# head [-n number]档案
  选项与参数：
  -n：后面接数字，代表显示几行的意思
  
  [root@study~]# head /etc/man_db.conf
  #预设的情况中，显示前面十行！若要显示前20行，就得要这样：
  [root@study~]# head -n 20 /etc/man_db.conf
  
  示例：如果后面100行的数据都不打印，只打印/etc/man_db.conf的前面几行，该如何是好？
  [root@study~]# head -n -100 /etc/man_db.conf
  ```

* `tail` (取出后面几行)

  ```shell
  [root@study~]# tail [-n number]档案
  选项与参数：
  -n：后面接数字，代表显示几行的意思
  -f：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测
  
  [root@study~]# tail /etc/man_db.conf
  #预设的情况中，显示最后的十行！若要显示最后的20行，就得要这样：
  [root@study~]# tail -n 20 /etc/man_db.conf
  
  示例一：如果不知道/etc/man_db.conf有几行，却只想列出100行以后的数据时？
  [root@study~]# tail -n +100 /etc/man_db.conf
  
  示例二：持续侦测/var/log/messages的内容
  [root@study~]# tail -f /var/log/messages
  <==要等到输入[ctrl]-c之后才会离开tail这个指令的侦测！
  ```

### 6.3.4 非纯文字文件：od

```shell
[root@study~]# od [-t TYPE]档案
选项或参数：
-t：后面可以接各种『类型（TYPE）』的输出，例如：
a：利用预设的字元来输出；
c：使用ASCII字元来输出
d[size]：利用十进制（decimal）来输出数据，每个整数占用size bytes；
f[size]：利用浮点数值（floating）来输出数据，每个数占用size bytes；
o[size]：利用八进位（octal）来输出数据，每个整数占用size bytes；
x[size]：利用十六进位（hexadecimal）来输出数据，每个整数占用size bytes；
```

### 6.3.5 修改文件时间或新建文件：touch

使用`ls`指令时，提到过一些时间相关参数。主要有三个变动时间：

- **modification time （mtime）**：
  当该文件的**「内容资料」**变更时，就会更新这个时间！ 内容数据指的是文件的内容，而不是文件的属性或权限喔！
- **status time （ctime）**：
  当该档案的**状态** （status）改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。
- **access time （atime）**：
  当该文件的**内容被取用**时，就会更新这个读取时间 （access）。 举例来说，我们使用 `cat` 去读取 `/etc/man_db.conf `， 就会更新该档案的 atime 了。

```shell
[root@study~]# touch [-acdmt] 档案
选项与参数：
-a：仅修订access time；
-c：仅修改档案的时间，若该档案不存在则不建立新档案；
-d：后面可以接欲修订的日期而不用目前的日期，也可以使用--date=“日期或时间”
-m：仅修改mtime；
-t：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]
```

在预设状态下，如果`touch`后面有接文件，则该文件的三个时间（atime，mtime，ctime）都会更新为当前时间。若文件不存在，则会建立一个空文件。

要注意的是，即使我们复制一个文件时，复制所有的属性，但也没有办法复制 `ctime` 这个属性的。

`touch`命令最常用的情形：

* 新建一个空文件
* 修改某文件的`mtime`和`atime`为当前。

## 6.4 文件与目录的预设权限与隐藏权限

### 6.4.1 档案预设权限：umask

 `umask` 就是指定 『当前用户在建立文件或目录时候的权限预设值』。

查看`umask`:

```shell
[root@study ~]# umask
0022             <==與一般權限有關的是後面三個數字！第一个数字0为特殊权限。
[root@study ~]# umask -S
u=rwx,g=rx,o=rx
```

要注意的是，`umask `的分数指的是**该预设值需要减掉的权限！**

预设情况下：

* 用户新建文件默认权限分为666，即`-rw-rw-rw-`。
* 用户新建目录默认权限分为777，即`drwxrwxrwx`。

`umask`分数是在上面预设分数的基础上减去相应的`umask`分数。

示例：

```shell
#预设情况下，新建文件默认权限分为666，新建目录为777
root@localhost:~# touch file1
root@localhost:~# mkdir dir1
root@localhost:~# ll -d file1 dir1
drwxrwxrwx 2 root root 4096 3月  31 13:33 dir1/
-rw-rw-rw- 1 root root    0 3月  31 13:33 file1

#设置umask为002，即拿掉预设情况下的w权限
root@localhost:~# umask 002
root@localhost:~# touch file2
root@localhost:~# mkdir dir2
root@localhost:~# ll -d file2 dir2
drwxrwxr-x 2 root root 4096 3月  31 13:34 dir2/
-rw-rw-r-- 1 root root    0 3月  31 13:34 file2
```

### 6.4.2 文件隐藏属性

* `chattr`(配置文件隐藏属性)

  ```shell
  [root@study~]# chattr [+-=][ASacdistu]档案或目录名称
  选项与参数：
  +：增加某一个特殊参数，其他原本存在参数则不动。
  -：移除某一个特殊参数，其他原本存在参数则不动。
  =：设定一定，且仅有后面接的参数
  A：当设定了A这个属性时，若你有存取此档案（或目录）时，他的存取时间atime将不会被修改，可避免I/O较慢的机器过度的存取磁盘。（目前建议使用档案系统挂载参数处理这个项目）
  S：一般档案是非同步写入磁盘的（原理请参考前一章sync的说明），如果加上S这个属性时，当你进行任何档案的修改，该更动会『同步』写入磁盘中。
  a：当设定a之后，这个档案将只能增加数据，而不能删除也不能修改资料，只有root才能设定这属性
  c：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存（看来对于大档案似乎蛮有用的！）
  d：当dump程序被执行的时候，设定d属性将可使该档案（或目录）不会被dump备份
  i：这个i可就很厉害了！他可以让一个档案『不能被删除、改名、设定连接也无法写入或新增数据！』对于系统安全性有相当大的助益！只有root能设定此属性
  s：当档案设定了s属性时，如果这个档案被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法救回来了喔！
  u：与s相反的，当使用u来设定档案时，如果该档案被删除了，则数据内容其实还存在磁盘中，可以使用来救援该档案喔！
  ```

  （`a` `i`属性较为常用）

  **注意1：属性设定常见的是a与i的设定值，而且很多设定值必须要身为root才能设定**
  **注意2:xfs档案系统仅支持AadiS而已**

* `lsattr`（显示文件隐藏属性）

  ```shell
  [root@study~]# lsattr [-adR]档案或目录
  选项与参数：
  -a：将隐藏档的属性也秀出来；
  -d：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；
  -R：连同子目录的数据也一并列出来！
  [root@studytmp]# chattr +aiS attrtest
  [root@studytmp]# lsattr attrtest
  --S-ia---------- attrtest
  ```

### 6.4.3 档案特殊权限：SUID, SGID, SBIT

(乍看一头雾水，本节内容与**系统账号**和**系统的程序**章节内容相关)

文件的重要权限除了`r` `w` `x`外，还有其它特殊权限，如`s` `t`。

* Set UID

  - SUID 权限仅对二进制程序（binary program）有效;
  - 执行者对于该程序需要具有 x 的可执行权限;
  - 本权限仅在执行该程序的过程中有效（run-time）;
  - 执行者将具有该程序所有者（owner）的权限。

  例如`/etc/shadow`这个文件仅有root可读且只有root可以强制写入，但用户却可以通过`/usr/bin/passwd`命令修改自己账号密码。因为 `/usr/bin/passwd`这个文件具有`s`特殊属性，普通用户这行这个命令时，可以暂时获得该命令的所有者(root)的权限。

  ![SUID程序执行的过程示意图](%E7%AC%94%E8%AE%B0.assets/centos7_suid.gif)

* Set GID

  SUID可以对文件或目录设定。对文件来说， SGID具有以下功能：

  - SGID 对二进制程序有用;
  - 程序执行者对于该程序来说，需具备 x 的权限;
  - 执行者在执行的过程中将会获得该程序组支持！

  对于目录，SGID有以下功能：

  - 用户若对于此目录具有 r 与 x 的权限时，该用户能够进入此目录;
  - 用户在此目录下的有效群组（effective group）将会变成该目录的群组;
  - 用途：若用户在此目录下具有 w 的权限（可以新建档案），则使用者所建立的新档案，该新档案的群组与此目录的群组相同。

* Sticky Bit

  SBIT仅对目录有效，作用如下：

  - 当用户对于此目录具有 w， x 权限，亦即具有写入的权限时;
  - 当用户在该目录下建立文件或目录时，仅有自己与 root 才有权力删除该档案

  > 我的理解：这个权限用于限制w权限的能力。当一个用户对某目录就有`w`的权限时，他不仅可以在此目录下删除、更改、移动自己创建的文件，也可以对别人的文件进行上述操作。对一个目录加上`SBIT`权限时，就拿掉了此用户删除、更改、移动别人的文件的权限。

* SUID/SGID/SBIT 权限设定

  **在之前学到的三位数字型权限前再加一位数字，用于表示SUID/SGID/SBIT权限**。

  三种数字权限分数如下：

  - 4 为SUID
  - 2 为 SGID
  - 1 为 SBIT

  示例：

  ```shell
  shang@localhost:/tmp$ touch test
  # 在751权限的基础上，为文件设置SUID、SGID权限
  shang@localhost:/tmp$ chmod 6754; ls -l test
  -rwsr-sr-- 1 shang shang 0 3月  31 15:19 test*
  
  # 在754的基础上，为目录设置SBIT权限
  shang@localhost:/tmp$ mkdir dir
  shang@localhost:/tmp$ chmod 1754 dirtest
  shang@localhost:/tmp$ ll -d dir
  drwxr-xr-T 2 shang shang 4096 3月  31 15:54 dir/ #注意！这个other权限第三项T为大写
  ```

  `s` 和 `t`都是用来取代 `x`权限的。

  但`s`  和 `t`的生效前提是必须具有 `x`权限，当这个生效前提不被满足，且设置权限时又恰好设置了`s` `t` 时，会用大写字母 `S` `T` 来表示这个权限其实是空的。

  > 暂时的疑惑：
  >
  > SBIT权限约束的是全部用户还是仅仅是Other用户？
  >
  > 1. 当目录权限分数为1771时，查看目录权限显示为`t`，此时的owner和group用户可以修改别人的文件吗？
  > 2. 当目录权限分数为1770时，查看目录权限为`T`,此时的owner和group用户可以修改别的文件吗？

  

  **使用符号法来处理**

  示例

  ```shell
  shang@localhost:/tmp$ chmod u=rws,go=x dir; ll -d dir
  drwS--x--x 2 shang shang 4096 3月  31 15:54 dir/
  
  shang@localhost:/tmp$ chmod g+s,o+t dir; ll -d dir
  drwS--s--t 2 shang shang 4096 3月  31 15:54 dir/
  ```

### 6.4.4 观察文件类型：file

```shell
[root@study~]# file ~/.bashrc
/root/.bashrc: ASCII text <==告诉我们是ASCII的纯文字档啊！
[root@study~]# file /usr/bin/passwd
/usr/bin/passwd: setuid ELF 64-bit LSB shared object，x86-64，version 1（SYSV），dynamically
linked（uses shared libs），for GNU/Linux 2.6.32，
BuildID[sha1]=0xbf35571e607e317bf107b9bcf65199988d0ed5ab，stripped
#执行档的数据可就多的不得了！包括这个档案的suid权限、兼容于Intel x86-64等级的硬件平台
#使用的是Linux核心2.6.32的动态函式库连接等等。
[root@study~]# file /var/lib/mlocate/mlocate.db
/var/lib/mlocate/mlocate.db: data <==这是data档案！
```

## 6.5 指令与文件的搜寻

### 6.5.1 指令文件名的搜寻

* `which`（寻找执行文件）

  ```shell
  [root@study~]# which [-a] command
  选项或参数：
  -a：将所有由PATH目录中可以找到的指令均列出，而不止第一个被找到的指令名称
  ```

  这个指令是根据[PATH](#6.1.3 关于可执行文件路径的变量：$PATH)这个环境变量所规范的路径，去搜索执行文件的文件名

### 6.5.2 文件文件名的搜寻

查找文件很少用`find`。

 `whereis` 只找系统中某些特定目录底下的档案而已，`locate` 则是利用数据库来搜索文件名，当然两者就相当的快速， 并且没有实际的搜索硬盘内的文件系统状态。

* `whereis` (从一些特定的目录中查找文件名)

  ```shell
  [root@study~]# whereis [-bmsu]档案或目录名
  选项与参数：
  -l：可以列出whereis会去查询的几个主要目录而已
  -b：只找binary格式的档案
  -m：只找在说明档manual路径下的档案
  -s：只找source来源档案
  -u：搜寻不在上述三个项目当中的其他特殊档案
  ```

  示例：

  ```shell
  # 全部文件名全部列出
  shang@localhost:/tmp$ whereis passwd
  passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man1/passwd.1ssl.gz /usr/share/man/man5/passwd.5.gz
  
  # 只查找在man里面的文件名
  shang@localhost:/tmp$ whereis -m passwd
  passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man1/passwd.1ssl.gz /usr/share/man/man5/passwd.5.gz
  ```

* `locate`/`updatedb`

  - `updatedb`：根据` /etc/updatedb.conf `的设定去搜寻系统硬盘内的文件名，并更新` /var/lib/mlocate `内的数据库档案;
  - `locate`：依据 `/var/lib/mlocate `内的数据库记载，找出用户输入的关键词档名。

  ```shell
  [root@study~]# locate [-ir] keyword
  选项与参数：
  -i：忽略大小写的差异；
  -c：不输出文件名，仅计算找到的档案数量
  -l：仅输出几行的意思，例如输出五行则是-l 5
  -S：输出locate所使用的数据库档案的相关资讯，包括该数据库纪录的档案/目录数量等
  -r：后面可接正规表示法的显示方式
  ```

* `find`

  **与时间有关的参数**

  ```shell
  [root@study~]# find [PATH] [option] [action]
  选项与参数：
  与时间有关的选项：共有-atime，-ctime与-mtime，以-mtime说明
  -mtime n :n为数字，意义为在n天之前的『一天之内』被更动过内容的档案；
  -mtime +n：列出在n天之前（不含n天本身）被更动过内容的档案文件名；
  -mtime -n：列出在n天之内（含n天本身）被更动过内容的档案文件名。
  -newer file :file为一个存在的档案，列出比file还要新的档案文件名
  
  上述选项中mtime可以替换为atime、ctime.
  ```

  示例：

  ```shell
  # 在/tmp目录中查找24小时内修改过的文件（0代表当前）
  shang@localhost:/tmp$ find /tmp -mtime 0
  ```

  ![find 相关的时间参数意义](%E7%AC%94%E8%AE%B0.assets/find_time.gif)

  ​                                                                          find 相关的时间参数意义

  **与使用者或群组名有关的参数：**

  ```shell
  -uid n :n为数字，这个数字是使用者的帐号ID，亦即UID，这个UID是记录在
  /etc/passwd里面与帐号名称对应的数字。这方面我们会在第四篇介绍。
  -gid n :n为数字，这个数字是群组名称的ID，亦即GID，这个GID记录在
  /etc/group，相关的介绍我们会第四篇说明～
  -user name :name为使用者帐号名称喔！例如dmtsai
  -group name:name为群组名称喔，例如users；
  -nouser：寻找档案的拥有者不存在/etc/passwd的人！
  -nogroup：寻找档案的拥有群组不存在于/etc/group的档案！
  当你自行安装软件时，很可能该软件的属性当中并没有档案拥有者，
  这是可能的！在这个时候，就可以使用-nouser与-nogroup搜寻。
  ```

  **与文件权限及名称有关的参数**

  ```shell
  -name filename：搜寻档案名称为filename的档案；
  -size [+-]SIZE：搜寻比SIZE还要大（+）或小（-）的档案。这个SIZE的规格有：
  c:代表byte，k:代表1024bytes。所以，要找比50KB
  还要大的档案，就是『-size +50k』
  -type TYPE：搜寻档案的类型为TYPE的，类型主要有：一般正规档案（f），装置档案（b，c），
  目录（d），连接档（l），socket（s），及FIFO（p）等属性。
  -perm mode：搜寻档案权限『刚好等于』mode的档案，这个mode为类似chmod
  的属性值，举例来说，-rwsr-xr-x的属性为4755！
  -perm -mode：搜寻档案权限『必须要全部囊括mode的权限』的档案，举例来说，
  我们要搜寻-rwxr--r--，亦即0744的档案，使用-perm -0744，
  当一个档案的权限为-rwsr-xr-x，亦即4755时，也会被列出来，
  因为-rwsr-xr-x的属性已经囊括了-rwxr--r--的属性了。
  -perm /mode：搜寻档案权限『包含任一mode的权限』的档案，举例来说，我们搜寻
  -rwxr-xr-x，亦即-perm /755时，但一个档案属性为-rw-------
  也会被列出来，因为他有-rw….的属性存在！
  ```

  **额外可进行的动作**

  ```shell
  -exec command :command为其他指令，-exec后面可再接额外的指令来处理搜寻到的结果。
  -print：将结果打印到屏幕上，这个动作是预设动作！
  示例八：将上个示例找到的档案使用ls -l列出来～
  [root@study~]# find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \；
  #注意到，那个-exec后面的ls -l就是额外的指令，指令不支持命令别名，
  #所以仅能使用ls -l不可以使用ll喔！注意注意！
  ```

  - `{}` 代表的是『由 `find` 找到的内容』，如上图所示，`find `的结果会被放置到 `{} `位置中;
  - `-exec` 一直到 `\; `是关键词，代表 `find `额外动作的开始 （`-exec`） 到结束 （`\;`) ，在这中间的就是 `find `指令内的额外动作。 在本例中就是『 `ls -l {} `』啰！
  - 因为 `; `在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。

# 七、Linux磁盘与档案系统管理
## 7.1 认识Linux文件系统
### 7.1.1 磁盘组成与分割的复习
(略)
### 7.1.2 档案系统特性
Linux的正统文件系统为`Ext2`。

传统的磁盘与档案系统应用中一个分割槽只能被格式化为一个文件系统，即一个filesystem就是一个partition（但LVM与磁盘阵列可以经一个分割槽格式化为多个文件系统）。

关于`inode` `block` `superblock` 的简要说明：
* `superblock`: 记录此filesystem的整体信息，包括`inode`/`block` 的总量、使用量、剩余量以及文件系统的格式等相关信息。

* `inode`: 记录文件的属性，一个文件占用的`inode`. 同时记录此文件的数据所在的`block`号码。

* `block`: 实际记录文件的内容，若文件太大时，会占用多个block。

例如`inode` 4号记录了放置在2,7,13, 15四个`block`的文件，图示如下：

<img src="笔记.assets/filesystem-1.jpg" />

这种数据访问的方式成为**索引式文件系统**。

### 7.1.3 Linux的EXT2文件系统

当文件系统高达百G时，将所有`inode`和`block`都放在一起不易管理，因此Ext文件系统在格式化时区分出多个区块（block group）,每个区块都有独立的`inode`/`block`/`superblock`系统。如下图所示：

<img src="笔记.assets/ext2_filesystem.jpg" />



文件系统最前面的有个开机扇区，这个开机扇区可以安装开机管理程序（详见[BIOS搭配MBR/GPT的开机流程](#1. BIOS搭配MBR/GPT的开机流程：)）

下面介绍区块组的六个主要内容：

* `data block`(数据块）

	Ext2文件系统支持的block大小有1k,2k以及4k三种。

	|Block大小|1KB|2KB|4KB|
	|---------|---|---|---|
	|最大单一文件限制|16GB|256GB|2TB|
	|最大文件系统总容量|2TB|8TB|16TB|

	**Ext2系统的限制：**
	* 原则上，`block`的大小与数量在格式化后就不能改变了（除非重新格式化）
	* 每个block内最多只能放置一个文件的数据
	* 承上， 如果文件大于block的大小，则一个文件会占用多个`block`；
	* 承上，若文件小于block，则被占用的blcok剩余的容量就不能再被使用了。
	
* `inode table`(inode表格）

	`inode`表格至少记录以下数据：
	* 该文件的访问模式(read/write/excute)
	* 该文件的所有者与组（owner/group）
	* 该文件的容量
	* 该文件建立或状态改变的时间（ctime）
	* 最近一次读取的时间（atime）
	* 最近修改的时间（mtime）
	* 定义文件特性的标志（flag），如SetUID...
	* 该文件真正的内容指向（pointer）
	
	除此之外，`inode`的一些特征：
	* 每个`inode`大小均固定为128bytes (新的ext4和xfs可以配置到256bytes)
	* 每个文件仅占用一个`inode`
	* 承上，因此文件系统能建立的文件数量与`inode`数量有关
	* 系统读取文件时会先读取`inode`,再分析`inode`记录的权限与用户是否符合，若符合才开始实际读取`block`的内容

	针对单个文件过大的情况，`inode`记录`block`号码的区域定义为12个直接，一个间接和，一个双间接和一个三简介记录区，关系如下：
	
	<img src="笔记.assets/inode.jpg" />


* `Superblock` (超级区块）

	记录的信息主要有：
	* `block` 与`inode`的数量
	* 未使用与已使用的`inode` / `block`数量
	* `block` 与 `inode`的大小（block为1，2，4k, inode为128bytes或256bytes）
	* filesystem的挂载时间，最近一次写入数据的时间、最近一次检查磁盘的时间等文件系统的相关信息
	* 一个`valid bit`数值，若此文件系统已被挂载，则`valid bit`为0，否则为1

* `Filesystem Description`(文件系统描述说明）

这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段（superblock，bitmap， inodemap， data block） 分别介于哪一个block号码之间。

* `block bitmap` (区块对照表）

 从block bitmap当中可以知道哪些block是空的。

* `inode bitmap`(inode 对照表)

inode bitmap则是记录使用与未使用的inode号码。

* `dumpe2fs`:查询Ext家族`superblock`信息的指令
```shell
[root@study~]# dumpe2fs [-bh]装置文件名
选项与参数：
-b：列出保留为坏轨的部分（一般用不到吧！？）
-h：仅列出superblock的数据，不会列出其他的区段内容！
```

### 7.1.4与目录树的关系
* 目录
	当我们在 Linux 下的文件系统建立一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。 其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块block号码; 而 block 则是记录在这个目录下的文件名与该档名占用的 inode 号码数据。

	实际观察文件站用户的`inode`号码，可以使用`ls -i`来显示：
	```shell
	shang@local ~ $ ll -i
	total 44K
	1597821 drwxr-xr-x  2 shang shang 4.0K 4月   2 09:19 Desktop
	1597825 drwxr-xr-x  2 shang shang 4.0K 4月   2 09:19 Documents
	```

* 目录树读取
	```shell
	[root@study ~]# ll -di / /etc /etc/passwd
	     128 dr-xr-xr-x.  17 root root 4096 May  4 17:56 /
	33595521 drwxr-xr-x. 131 root root 8192 Jun 17 00:20 /etc
	36628004 -rw-r--r--.   1 root root 2092 Jun 17 00:20 /etc/passwd
	
	```

	上述命令的文件读取流程为：

	1.  ` /inode` ：
	通过挂载点的信息找到` inode` 号码为 128 的根目录 `inode`，且 `inode` 规范的权限让我们可以读取该 `block` 的内容（有 r 与 x） ;
	2. ` / `的 `block`：
	经过上个步骤取得 `block` 的号码，并找到该内容有 `etc/` 目录的 `inode` 号码 （33595521）;
	3. `etc/`的`inode`:
	读取 33595521 号 `inode` 得知 `dmtsai` 具有 r 与 x 的权限，因此可以读取 `etc/` 的 `block` 内容;
	4. `etc/` 的 `block`：
	经过上个步骤取得 `block` 号码，并找到该内容有 `passwd` 档案的 inode 号码 （36628004）;
	5. `passwd` 的 `inode`：
	读取 36628004 号 `inode` 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 `block` 内容;
	6. `passwd` 的 `block`：
	最后将该 block 内容的数据读出来。

### 7.1.5 Ext2/Ext3/Ext4文件的访问与日志式文件系统的功能

当用户新建一个文件时，此时文件系统的行为是：
1. 先确定用户对于新增文件的目录是否具有`w`和`x`的权限，若有的话才能新增；
2. 根据`inode bitmap` 找到没有使用的`inode`号码，并将新文件的权限/属性写入；
3. 根据`block bitmap`找到没有使用中的`block`号码，并将实际的数据写入`block`中，且更新`inode`的`block`指向资料；
4. 将刚刚写入的`inode`与`block`资料同步更新`inode bitmap` 与`block bitmap`, 并更新`superblock`的内容。

因为`superblock`, `inode bitmap`和`block bitmap`的数据时经常变动的，新增、移除、编辑都会影响到这三个部分的数据，因此别成为**中介资料**(metadata)。

实际情况下，当文件系统在上述步骤中某一步意外中断时，就会导致**资料的不一致（Inconsistent）状态**。

* 日志式文件系统

为避免出现文件系统的不一致情况发生，在filesystem中划出一块区块，该区块专门记录写入或修订文件的步骤：

1. 预备：当系统要写入一个文件时，会先在日志记录区块中记录某文件要写入的信息。
2. 实际写入：开始写入文件的权限与数据，开始个您`metadata`的数据； 
3. 结束：完成资料与`metadata`的更新后，在日志记录区块中完成该文件的记录。

### 7.1.6 Linux 文件系统的运作

系统加载一个文件到内存后，如果内存中的该文件数据被修改过了，此时内存中该文件的数据就会被设定成脏的（Dirty）。此时的所有动作都还在内存中执行，并没有写入到磁盘。 系统会不定时将内存中的‘Dirty’数据写会磁盘，来保证磁盘与内存数据的一致性。

* 可以手动使用`sync`命令强制'Dirty'数据写回；
* 正常关机，关机指令会主动呼叫`sync`写会数据；
* 异常关机，数据可能未正常写回，引发一系列问题。

### 7.1.7 挂载点的意义

挂载点一定是目录，该目录为进入该档案系统的入口。 因此并不是你有任何档案系统都能使用，必须要'挂载'到目录树的某个目录后，才能够使用该档案系统的。

## 7.2文件系统的简单操作

### 7.2.1磁盘与目录的容量

* `df`: 列出文件系统的整体磁盘使用量
* `du`:评估文件系统的磁盘使用量。

**df**

```shell
[root@study~]# df [-ahikHTm] [目录或文件名]
选项与参数：
-a：列出所有的档案系统，包括系统特有的/proc等档案系统；
-k：以KBytes的容量显示各档案系统；
-m：以MBytes的容量显示各档案系统；
-h：以人们较易阅读的GBytes，MBytes，KBytes等格式自行显示；(常用）
-H：以M=1000K取代M=1024K的进位方式；
-T：连同该partition的filesystem名称（例如xfs）也列出；
-i：不用磁盘容量，而以inode的数量来显示(常用）

#示例
shang@local ~ $ df
Filesystem     1K-blocks     Used Available Use% Mounted on
udev             5330916        0   5330916   0% /dev
tmpfs            1072880     1908   1070972   1% /run
/dev/sda5       30313412 10888264  17862268  38% /
tmpfs            5364380        0   5364380   0% /dev/shm
```

输出信息：
* Filesystem：代表该文件系统输入哪个partition；
* Mounted on: 磁盘挂载的目录（挂载点）。

**du**

```shell
[root@study~]# du [-ahskm]档案或目录名称
选项与参数：
-a：列出所有的档案与目录容量，因为预设仅统计目录底下的档案量而已。
-h：以人们较易读的容量格式（G/M）显示；(默认情况下单位为KB)
-s：列出总量而已，而不列出每个各别的目录占用容量；
-S：不包括子目录下的总计，与-s有点差别。
-k：以KBytes列出容量显示；
-m：以MBytes列出容量显示；
```

### 7.2.2 实体链接与符号链接：ln
* Hard Line(物理链接）

	* 每个文件都会占用一个`inode`, 文件内容由`inode`的记录来指向;
	* 想要读取某档案，必须要经过目录记录的文件名来指向到正确的`inode`号码才能读取。

	设置`/dir1/fielA` hardline到 `/dir2/fileB`, 只是在`/dir1`目录下添加一笔文件名链接到 `/dir2/fileB`的`inode`而已。
	> (我的理解）文件系统在`/dir1`的'block`中寻找到的`/dir1/fileA`的`inode`其实就是`/dir2/fileB`的`inode`。
	
	示例：
	
	```shell
	[root@study ~]# ll -i /etc/crontab
	34474855 -rw-r--r--. 1 root root 451 Jun 10  2014 /etc/crontab
	
	[root@study ~]# ln /etc/crontab .   <==建立實體連結的指令
	[root@study ~]# ll -i /etc/crontab crontab
	34474855 -rw-r--r--. 2 root root 451 Jun 10  2014 crontab # 数字2表示有两个档名链接到这个inode号码
	34474855 -rw-r--r--. 2 root root 451 Jun 10  2014 /etc/crontab	
	```
	
	上述链接示意图：
	
	<img src="笔记.assets/hard_link1.gif" />
	
	**Hard line的限制**：
		* 不能跨 Filesystem;
		* 不能link目录
	
* Symbolic line（符号链接）
	Symboliclink就是在建立一个独立的档案，而这个档案会让数据的读取指向他link的那个档案的文件名.

	当源文件被删除之后，symbolic line的文件就无法打开。

	示例：
	```shell
	[root@study ~]# ln -s /etc/crontab crontab2
	[root@study ~]# ll -i /etc/crontab /root/crontab2
	34474855 -rw-r--r--. 2 root root 451 Jun 10  2014 /etc/crontab
	53745909 lrwxrwxrwx. 1 root root  12 Jun 23 22:31 /root/crontab2 -> /etc/crontab
	```
	图示：
	
	<img src="笔记.assets/symbolic_link1.gif" />
	
* `ln`指令用法
	```shell
	[root@study ~]# ln [-sf] 來源檔 目標檔
	選項與參數：
	-s  ：如果不加任何參數就進行連結，那就是hard link，至於 -s 就是symbolic link
	-f  ：如果 目標檔 存在時，就主動的將目標檔直接移除後再建立！
	```

## 7.3磁盘的分割、格式化、检验与挂载

## 7.4设定开机挂载

## 7.5内存置换空间(swap)的配置

## 7.6文件系统的特殊观察与操作

# 八、文件与档案系统的压缩，打包与备份



## 8.2 Linux 系统常见的压缩指令

```shell
*.Z         compress 程式壓縮的檔案；
*.zip       zip 程式壓縮的檔案；
*.gz        gzip 程式壓縮的檔案；
*.bz2       bzip2 程式壓縮的檔案；
*.xz        xz 程式壓縮的檔案；
*.tar       tar 程式打包的資料，並沒有壓縮過；
*.tar.gz    tar 程式打包的檔案，其中並且經過 gzip 的壓縮
*.tar.bz2   tar 程式打包的檔案，其中並且經過 bzip2 的壓縮
*.tar.xz    tar 程式打包的檔案，其中並且經過 xz 的壓縮
```


### 8.2.1 gzip, zcat/zmore/zless/zgrep

```shell
[dmtsai@study~]$ gzip [-cdtv#]文件名
[dmtsai@study~]$ zcat 文件名.gz
选项与参数：
-c：将压缩的数据输出到屏幕上，可透过数据流重导向来处理；
-d：解压缩的参数；
-t：可以用来检验一个压缩档的一致性～看看档案有无错误；
-v：可以显示出原档案/压缩档案的压缩比等信息；
-# :#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！预设是-6
```

示例：
```shell
# 压缩Git.md文件，压缩等级为9，并保留原文件，压缩后的文件为Git.gz
shang@local ~/Learning (vubuntu_pc?) $ gzip -cv -9 git/Git.md>Git.gz 
git/Git.md:	 65.5%
```
### 8.2.2 bzip, bzcat/bzmore/bzless/bzgrep

```shell
[dmtsai@study~]$ bzip2 [-cdkzv#]文件名
[dmtsai@study~]$ bzcat文件名.bz2
选项与参数：
-c：将压缩的过程产生的数据输出到屏幕上！
-d：解压缩的参数
-k：保留原始档案，而不会删除原始的档案喔！
-z：压缩的参数（预设值，可以不加）
-v：可以显示出原档案/压缩档案的压缩比等信息；
-#：与gzip同样的，都是在计算压缩比的参数，-9最佳，-1最快！
```
### 8.2.3  xz, xzcat/xzmore/xzless/xzgrep

(因为这个命令用法和上面很相似，所以略过）

虽然 bzip2 已经具有很棒的压缩比，不过显然某些自由软件开发者还不满足，因此后来还推出了 xz 这个压缩比更高的软件！

## 8.3打包指令 tar

### 8.3.1 tar

```shell
[dmtsai@study~]$ tar [-z|-j|-J] [cv] [-f待建立的新文件名] filename…<==打包与压缩
[dmtsai@study~]$ tar [-z|-j|-J] [tv] [-f既有的tar文件名] <==察看文件名
[dmtsai@study~]$ tar [-z|-j|-J] [xv] [-f既有的tar文件名] [-C目录] <==解压缩
选项与参数：
-c：建立打包档案，可搭配-v来察看过程中被打包的文件名（filename）
-t：察看打包档案的内容含有哪些文件名，重点在察看『文件名』就是了；
-x：解打包或解压缩的功能，可以搭配-C（大写）在特定目录解开
特别留意的是，-c，-t，-x不可同时出现在一串指令列中。
-z：透过gzip的支持进行压缩/解压缩：此时文件名最好为*.tar.gz
-j：透过bzip2的支持进行压缩/解压缩：此时文件名最好为*.tar.bz2
-J：透过xz的支持进行压缩/解压缩：此时文件名最好为*.tar.xz
特别留意，-z，-j，-J不可以同时出现在一串指令列中
-v：在压缩/解压缩的过程中，将正在处理的文件名显示出来！
-f filename:-f后面要立刻接要被处理的文件名！建议-f单独写一个选项啰！（比较不会忘记）
-C目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
其他后续练习会使用到的选项介绍：
-p（小写）：保留备份数据的原本权限与属性，常用于备份（-c）重要的设定档
-P（大写）：保留绝对路径，亦即允许备份数据中含有根目录存在之意；
--exclude=FILE：在压缩的过程中，不要将FILE打包！
```

常用参数组合：

* 压缩： `tar -jcv -f filename.tar.bz2 要被压缩的文件或者目录名称`
* 查看： `tar -jtv -f filename.tar.bz2`
* 解压： `tar -jxv -f filebane.tar.bz2 -C 要解压到的目录`

(记法： tar + 用哪个软件？（j、z、x）+ 要干什么？（c、t、x）+ 其他命令)



# 九、vim程序编辑器

## 9.2 vi的使用

vi的三种模式：一般指令模式、编辑模式、指令模式。

三种模式相互关系如下图

![vi三种模式的相互关系](%E7%AC%94%E8%AE%B0.assets/centos7_vi-mode.gif)

### 9.2.2 按键说明

* 按键说明、光标移动、复制粘贴、搜索替换等

  ![image-20220331210819354](%E7%AC%94%E8%AE%B0.assets/image-20220331210819354.png)

  

  ![image-20220331210900334](%E7%AC%94%E8%AE%B0.assets/image-20220331210900334.png)

  

  ![image-20220331210925126](%E7%AC%94%E8%AE%B0.assets/image-20220331210925126.png)

  * 第二部分：一般指令模式切换到编辑模式可用的按键说明

    ![image-20220331211137816](%E7%AC%94%E8%AE%B0.assets/image-20220331211137816.png)

  * 第三部分，一般指令模式切换到指令行模式的可用按键说明

    ![image-20220331211231052](%E7%AC%94%E8%AE%B0.assets/image-20220331211231052.png)

### 9.3.1 区块选择

![image-20220404203502137](%E7%AC%94%E8%AE%B0.assets/image-20220404203502137.png)

### 9.3.2 多文件编辑

![image-20220404203535980](%E7%AC%94%E8%AE%B0.assets/image-20220404203535980.png)

### 9.3.3 多窗口功能

![image-20220404203627739](%E7%AC%94%E8%AE%B0.assets/image-20220404203627739.png)

### 9.3.4 Vim配置文件键盘映射（书中没有）

* 不同模式下的键盘映射

   <img src="笔记.assets/yingshe1.png" />

    * `Operator Pending`：是指你输入操作符时（例如d）,然后继续输入的移动步长和文本对象（dw）的状态.
    * 第一行定义的映射，仍然可以被重新映射.

* 键盘映射示例
    ```shell
    :map <F10> <Esc>:tabnew<CR>
    ```
    
    其中 `<Esc>` 代表Escape键，`<CR>`代表Enter键。

    同理对于组合键，可以用`<C-Esc>代表Ctr-Esc; 使用`<S-F1>`代表Shift-F1。

    Alt键可以使用`<M-key>`或`<A-key>`表示。

    使用`:h key-notation`查看帮助信息。

    使用`:map`查看所有键盘映射
